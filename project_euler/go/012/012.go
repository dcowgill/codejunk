/*

The sequence of triangle numbers is generated by adding the natural numbers.
So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first
ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred
divisors?

*/

package p012

const N = 500

func solve() int64 {
	s := NewPrimeSieve()
	var t int64
	for i := 1; ; i++ {
		t += int64(i) // ith triangle number
		if NumDivisors(t, s) > N {
			break
		}
	}
	return t
}

func NumDivisors(n int64, s *PrimeSieve) int {
	c := 1
	for _, factor := range PrimeFactors(n, s) {
		c *= (factor.Exponent + 1)
	}
	return c
}

type primeFactor struct {
	Base     int
	Exponent int
}

func PrimeFactors(n int64, s *PrimeSieve) []primeFactor {
	factors := make([]primeFactor, 0)
	s.Reset()
	for n > 1 {
		p := int64(s.Next())
		if n%p == 0 {
			exp := 0
			for n%p == 0 {
				n /= p
				exp++
			}
			factors = append(factors, primeFactor{int(p), exp})
		}
	}
	return factors
}

type PrimeSieve struct {
	x          int
	composites map[int][]int
	primes     []int
	n          int
}

func NewPrimeSieve() *PrimeSieve {
	s := new(PrimeSieve)
	s.x = 1
	s.composites = make(map[int][]int)
	s.primes = make([]int, 0)
	s.n = 0
	return s
}

func (s *PrimeSieve) Next() int {
	if s.n >= len(s.primes) {
		for {
			s.x++
			if primes, ok := s.composites[s.x]; ok {
				for _, prime := range primes {
					k := s.x + prime
					if xs, ok := s.composites[k]; ok {
						s.composites[k] = append(xs, prime)
					} else {
						s.composites[k] = []int{prime}
					}
				}
				delete(s.composites, s.x)
			} else {
				s.composites[s.x*s.x] = []int{s.x}
				break
			}
		}
		s.primes = append(s.primes, s.x)
	}
	s.n++
	return s.primes[s.n-1]
}

func (s *PrimeSieve) Reset() {
	s.n = 0
}

func (s *PrimeSieve) IsPrime(x int) bool {
	s.Reset()
	p := s.Next()
	for p < x {
		p = s.Next()
	}
	return p == x
}
